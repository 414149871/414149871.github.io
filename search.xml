<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-Speech Framework]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FFramework%2FFramework%2F</url>
    <content type="text"><![CDATA[Speech Framework 是Apple公司在2016年WWDC上介绍的一个语音识别的API。它是Siri用来做语音识别的框架。在你的应用里面可以使用 Speech APIs 来拓展和提高语音识别功能，而不仅仅是单纯的使用键盘。 Speech APIs的执行需要使用一个设备内置的语音识别器和连接到苹果的服务器。如果发现语音识别器是用于一个特定的语言，例如英文、国语等，可以采用 SFSpeechRecognizerDelegate 协议。 因为你的应用可能需要连接到服务器进行识别，而这涉及到尊重用户的隐私问题，出于这个原因，我们在启动语音识别功能之前必须得到用户的明确许可。 做了一个demo，使用Speech Framework 实现语音转文字的功能。 上面这个效果图中的文字是识别我的话转出来的，接下来我们来实现一下。 1.我们要写个句子告诉用户在应用中可以如何使用这个语音功能。例如，在这个例子中写了这么一句提示的话”Lets you mark an item as finished by saying Done.”。 2.在 Info.plist里面添加两个键值对，分别是Privacy - Speech Recognition Usage Description （用于请求语音识别） 以及 Privacy - Microphone Usage Description（用于请求麦克风语音输入授权）。 3.创建 SFSpeechRecognizer 对象，使用 requestAuthorization: 去申请用户语音识别权限 。 1@property (nonatomic,strong)SFSpeechRecognizer *speechRecognizer; 在viewDidLoad:中初始化 speechRecognizer对象，并设置代理。123456// zh-CN 代表是简体中文 NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh-CN&quot;]; _speechRecognizer = [[SFSpeechRecognizer alloc] initWithLocale:locale]; //把语音识别的代理设置为 self _speechRecognizer.delegate = self; 申请用户语音识别权限1234567891011121314151617181920212223242526272829303132[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; BOOL isButtonEnable = NO; //检查验证的状态。如果被授权了，让microphone按钮有效。如果没有，打印错误信息然后让microphone按钮失效。 switch (status) &#123; case SFSpeechRecognizerAuthorizationStatusAuthorized: &#123; isButtonEnable = YES; NSLog(@&quot;用户授权语音识别&quot;); &#125; break; case SFSpeechRecognizerAuthorizationStatusDenied: &#123; isButtonEnable = NO; NSLog(@&quot;用户拒绝授权语音识别&quot;); &#125; break; case SFSpeechRecognizerAuthorizationStatusRestricted: &#123; isButtonEnable = NO; NSLog(@&quot;设备不支持语音识别功能&quot;); &#125; break; case SFSpeechRecognizerAuthorizationStatusNotDetermined: &#123; isButtonEnable = NO; NSLog(@&quot;结果未知 用户尚未进行选择&quot;); &#125; break; &#125; 运行后我们会发现授权请示如下： 4.在用户允许通过语音识别和麦克风授权之后，写一个方发startRecording用于语音识别请求。12345678910111213141516171819202122232425262728293031//实例化recognitionRequest。在这里我们创建了SFSpeechAudioBufferRecognitionRequest对象。稍后我们利用它把语音数据传到苹果后台 _recognitionRequest = [SFSpeechAudioBufferRecognitionRequest new]; //当用户说话的时候让recognitionRequest报告语音识别的部分结果 _recognitionRequest.shouldReportPartialResults = YES; //调用 speechRecognizer的recognitionTask 方法来开启语音识别。这个方法有一个completion handler回调。这个回调每次都会在识别引擎收到输入的时候，完善了当前识别的信息时候，或者被删除或者停止的时候被调用，最后会返回一个最终的文本 (进行请求) _recognitionTask = [_speechRecognizer recognitionTaskWithRequest:_recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; //定义一个布尔值决定识别是否已经结束 BOOL isFinal = NO; //如果结果 result 不是nil, 把 textView.text 的值设置为我们的最优文本。如果结果是最终结果，设置 isFinal为true if (result != nil) &#123; self.textView.text = result.bestTranscription.formattedString; isFinal = result.isFinal; &#125; //如果没有错误或者结果是最终结果，停止 audioEngine(语音输入)并且停止 recognitionRequest 和 recognitionTask.同时，使Start Recording按钮有效 if (error != nil || isFinal) &#123; [self.audioEngine stop]; [inputNode removeTapOnBus:0]; self.recognitionRequest = nil; self.recognitionTask = nil; self.microphoneButton.enabled = YES; &#125; &#125;]; 在开始了recognitionTask之后向 recognitionRequest增加一个语音输入。Speech Framework 会在语音输入被加入的同时就开始进行解析识别1234567891011121314151617AVAudioSession *audioSession = [AVAudioSession sharedInstance]; [audioSession setCategory:AVAudioSessionCategoryRecord error:nil]; [audioSession setMode:AVAudioSessionModeMeasurement error:nil]; [audioSession setActive:YES withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:nil]; //检查 audioEngine（你的设备）是否有做录音功能作为语音输入 AVAudioInputNode *inputNode = [_audioEngine inputNode]; if (!inputNode) &#123; NSLog(@&quot;Audio engine has no input node&quot;); &#125;AVAudioFormat *recordingFormat = [inputNode outputFormatForBus:0]; [inputNode installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123; [self.recognitionRequest appendAudioPCMBuffer:buffer]; &#125;]; 准备并且开始audioEngine,并让textView的文本为 “Say something, I’m listening!”。123[_audioEngine prepare];[_audioEngine startAndReturnError:nil];_textView.text = @&quot;Say something, I&apos;m listening!&quot;; 我们让当前视图控制器作为speechRecognizer 的代理，在SFSpeechRecognizerDelegate中有可选的speechRecognizer:availabilityDidChange:方法，实现一下。12345678910//当语音识别操作可用性发生改变时会被调用- (void)speechRecognizer:(SFSpeechRecognizer *)speechRecognizer availabilityDidChange:(BOOL)available&#123; if (available) &#123; _microphoneButton.enabled = YES; &#125; else&#123; _microphoneButton.enabled = NO; &#125;&#125; 下面是一些LocaleIdentifier，可以参考一下需要的语言。 到此，使用Speech Framework实现了语音转文字功能实现了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-Speech Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-哔哩哔哩动画_富文本的使用]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A8%E7%94%BB-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%2FiOS-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A8%E7%94%BB-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[哔哩哔哩动画中有挺多效果可以用富文本实现，例如首页的直播界面。通过本文来看看如何使用富文本。 上图中，如当前xxx个直播以及每个item的标题前面的# xxx #类型分类的字体都是粉红色的，在这里是在一个label上使用富文本来实现的。当然你也可以用多个label，把对应的label的字体颜色设置为粉红色这种方式实现也可以。 以当前xxx个直播举个例子来说，xxx 这个数字是从网络请求回来的数据。拿到网络请求回来的数据，对它进行处理。 1234567891011ZBHPartition *partition = recommendData.partition;//count表示直播个数double count = partition.count;NSString *string = [NSString stringWithFormat:@&quot;当前%.0f个直播&quot;,count];//富文本的使用，先把字符串转成富文本，找出对应的位置设置成粉红色NSMutableAttributedString *mString = [[NSMutableAttributedString alloc] initWithString:string];NSRange range = [string rangeOfString:@&quot;个&quot;];[mString addAttribute:NSForegroundColorAttributeName value:RLCommonBgColor range:NSMakeRange(2,range.location - 2)];_tuiJianHeaderBtn.contentStringLabel.attributedText = mString; 到此，我们需要的这个效果就实现了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-哔哩哔哩动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-哔哩哔哩动画_开机动画]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A8%E7%94%BB-%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%2FiOS-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A8%E7%94%BB-%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[最近因为需要，做了下哔哩哔哩动画这个应用。从数据、素材的抓取、分类、测试，到应用的基本功能实现，确实用了一段时间。下面是做哔哩哔哩动画的开机动画效果的实现。 从图一到图二，中间的人物从小到大，从透明到呈现的过程。实现这个效果并不难，步骤如下1.在LuanchImage设置开机图片 2.使用CABasicAnimationGroup实现动画效果 这里创建了一个视图控制器类LaunchViewController，用于实现动画效果。设置两个属性，其中bgImageView是背景图，playImageView是做动画的图片。12@property (nonatomic,strong)UIImageView *bgImageView;@property (nonatomic,strong)UIImageView *playImageView; 给这两个属性懒加载 1234567891011121314151617- (UIImageView *)bgImageView&#123; if(!_bgImageView)&#123; _bgImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenHeight)]; _bgImageView.image = [UIImage imageNamed:@&quot;bilibili_splash_iphone_bg&quot;]; &#125; return _bgImageView;&#125;- (UIImageView *)playImageView&#123; if(!_playImageView)&#123; _playImageView = [[UIImageView alloc] initWithFrame:CGRectMake(ScreenWidth/2, ScreenHeight/2-100, 1, 1.3)]; _playImageView.image = [UIImage imageNamed:@&quot;bilibili_splash_default&quot;]; &#125; return _playImageView;&#125; 在viewDidLoad中把视图添加上去123[self.view addSubview:self.bgImageView];[self.bgImageView addSubview:self.playImageView];[self performSelector:@selector(animationLunch) withObject:self afterDelay:0]; animationLunch中实现组合动画效果123456789101112131415161718192021222324252627- (void)animationLunch&#123; CGFloat duration = 1.5; CABasicAnimation *scale = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; scale.fromValue = @1; scale.toValue = @(ScreenWidth - 40); scale.duration = duration; scale.repeatCount = 1; scale.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; CABasicAnimation *opacity = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; opacity.fromValue = @0; opacity.toValue = @1; opacity.duration = duration; scale.repeatCount = 1; CAAnimationGroup *animationGroup = [CAAnimationGroup animation]; animationGroup.animations = @[scale,opacity]; animationGroup.duration = duration; animationGroup.repeatCount = 1; //如果是一个动画CAAnimation,则需要将其removedOnCompletion设置为NO,要不然fillMode不起作用 animationGroup.removedOnCompletion = NO; //决定当前在非active时间段的行为,比如动画开始之前,动画结束之后 animationGroup.fillMode =kCAFillModeForwards; animationGroup.delegate = self; [self.playImageView.layer addAnimation:animationGroup forKey:nil];&#125; 让LaunchViewController遵循代理，并实现CAAnimationDelegate协议12345- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; [NSThread sleepForTimeInterval:2.0]; //移除开机动画 [self.bgImageView removeFromSuperview];&#125; 这个类要做的事情完成了，回到AppDelegate中，导入刚创建的类头文件，在application: didFinishLaunchingWithOptions:中加入以下代码,把动画添加到场景中123456_launchVC = [[LaunchViewController alloc] init]; //添加到场景 [self.window addSubview:_launchVC.view]; //放到最顶层 [self.window bringSubviewToFront:_launchVC.view]; [self performSelector:@selector(removeLunch) withObject:self afterDelay:2.0]; 到此，哔哩哔哩动画的开机动画效果就实现了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-哔哩哔哩动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-关于应用的优化问题]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-%E5%85%B3%E4%BA%8E%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%2FiOS-%E5%85%B3%E4%BA%8E%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一个应用的优化可能是无底洞的东西，随着掌握知识的增多、灵活亦或参考别人的思想，你可能会发现有更好的方法来优化应用。或者到了已经需要重构的地步了。 可以优化的方面有很多，例如一、操作流畅度的优化二、页面浏览速度优化三、首页启动速度优化四、数据库的优化五、服务器端和客户端的交互优化六、非技术性能优化等等… 一、操作流畅度的优化Tableview 优化（tableviewCell的加载优化）CollectionView优化（collectionViewCell的加载优化）ViewController加载优化（不同view之间的跳转，可以提前准备好数据） 二、页面浏览速度优化json的处理（iOS 自带的NSJSONSerialization）数据的分页（后端数据多的话，就要分页返回）内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序） 三、首页启动速度优化 启动过程中做的事情越少越好 不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新） 四、数据库的优化查询语句的优化分库分表（数据太多的时候，可以分不同的表或者库） 五、服务器端和客户端的交互优化：客户端尽量减少请求服务端尽量做多的逻辑处理 六、非技术性能优化产品设计的逻辑性界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）代码规范日常交流…]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-关于应用的优化问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-获取App内的素材]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-%E8%8E%B7%E5%8F%96App%E5%86%85%E7%9A%84%E7%B4%A0%E6%9D%90%2FiOS-%E8%8E%B7%E5%8F%96App%E5%86%85%E7%9A%84%E7%B4%A0%E6%9D%90%2F</url>
    <content type="text"><![CDATA[通过本文一起来看看如何获取某个App 的素材文件 当我们在练手app 开发的过程中,如果素材文件不足,而又在某个app内找到满意的素材。如果可以获取某个App 的素材文件作为这个非商业化的练手的app 开发素材,那么就可以大大的减少在美工上所需要花费的时间。 以获取微信的素材为例。获取微信的素材步骤如下：1.打开iTunes。选择应用。这里面并不需要我们连接手机 2.把我们所需要里面素材的应用拖到桌面，此时我们就可以得到该应用的ipa包，现在我们就得到了微信 6.3.23.ipa 3.把微信 6.3.23.ipa 的后缀 .ipa 改成 .zip ,然后解压该文件,得到如下 4.打开文件夹,在里面我们会找到一个叫做Payload的文件夹，在该文件夹下有一个WeChat的包，右键，选择显示包内容 5.打开包以后，大家就会看到微信里面的素材文件。如下图： 但是大家会发现在该文件里面素材文件只有一丢丢,好像并不全面。那是因为,在我们的一些新的工程里面,我们一般会将素材放在Assets文件夹里面,这里面也是一个道理。我们找到一个Assets.car这样的一个文件。 打开这种.car的文件需要借助一下一些插件。这里使用的插件是iOS-Images-Extractor,可以在github上搜索得到。如下图： 6.下载该插件,得到如下工程，打开工作空间workSpace 运行程序,得到如下界面 7.把Assets.car文件拖到里面 8.点击star,待解析完以后，选择OutPut Dir,就可以查看Assets.car里面的素材文件了 到此,我们就可以获取微信应用的素材文件。 当然，这里我们还有更简单的方法获取包内素材。就是在iTunes中把需要拿到素材的文件直接拖到插件运行的程序中,点击 start解压后,选择OutPut Dir,就可以查看Assets.car里面的所有图片素材文件了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-获取App内的素材</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-本地通知]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%2FiOS-%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[在iOS中,本地通知非常适用于基于时间的行为.例如,有一个需求是让用户专注做某件事情一段时间. 时间到了后给个通知告知.实现这样一个功能可以使用本地通知 实现如下效果: 本地通知实现步骤:1.创建本地通知对象 ( UILocalNotification )2.设置通知的属性3.让应用程序调用通知,使用UIApplication对象调用scheduleLocalNotification:方法4.在iOS8.0之后,在调度通知之前需要使用 UIApplication的对象方法registerUserNotificationSettings:来请求用户授权 代码实现定义本地通知对象属性12/** 创建本地通知对象*/@property (nonatomic,strong) UILocalNotification *lNotification; 懒加载123456789//懒加载- (UILocalNotification *)lNotification&#123; if (!_lNotification) &#123; _lNotification = [[UILocalNotification alloc] init]; &#125; return _lNotification;&#125; 设置通知的属性12345678910111213/** 设置通知的内容*/ self.lNotification.alertBody = @&quot;时间到了&quot;; /** 设置通知触发开始的时间*/ self.lNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3]; /** 设置时区*/ self.lNotification.timeZone = [NSTimeZone defaultTimeZone]; /** 设置应用图标右上角的数字*/ self.lNotification.applicationIconBadgeNumber = 1; /** 设置通知的音效(只有真机有效)*/ self.lNotification.soundName = UILocalNotificationDefaultSoundName; 让应用程序调用通知12/** 让应用程序调用通知*/ [[UIApplication sharedApplication] scheduleLocalNotification:self.lNotification]; 更新显示徽章数方法12/** 更新显示徽章数*/ [UIApplication sharedApplication].applicationIconBadgeNumber = 0; 在iOS8.0之后,在调度通知之前需要使用 UIApplication的对象方法registerUserNotificationSettings:来请求用户授权,该方法需要在application: didFinishLaunchingWithOptions: 中实现12345678910111213/** * 在iOS8.0之后,在调度通知之前需要使用 UIApplication的对象方法registerUserNotificationSettings:来请求用户授权 UIUserNotificationType: UIUserNotificationTypeBadge 接收到通知可更改程序的应用图标 UIUserNotificationTypeSound 接收到通知可播放声音 UIUserNotificationTypeAlert 接收到通知提示内容 */ if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge |UIUserNotificationTypeSound | UIUserNotificationTypeAlert categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125; 到此,可以实现本地通知功能.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-本地通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-定位]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-%E5%AE%9A%E4%BD%8D%2FiOS-%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[使用地图的CLLocationManager完成定位效果. 例子:定位当前所在位置,把所在城市的城市名显示在label上 实现定位效果步骤如下:1.导入头文件 &lt;CoreLocation/CoreLocation.h&gt;2.创建位置管理者 CLLocationManager 的对象,并设置代理3.实现代理对应协议的方法4.使用系统自带的 CLGeocoder 类,将经度和纬度解析成地名 代码实现如下: 1.导入头文件1#import &lt;CoreLocation/CoreLocation.h&gt; 2.创建位置管理者,和 CLGeocoder 类的对象.这里把他设置成属性12345/** 位置管理者*/@property (nonatomic,strong) CLLocationManager *LManager ;/** 将经度和纬度解析成地名*/@property (nonatomic,strong) CLGeocoder *geocoder; 使用懒加载初始化1234567891011121314151617181920//懒加载- (CLLocationManager *)LManager&#123; if (!_LManager) &#123; //创建位置管理者 _LManager = [[CLLocationManager alloc] init]; _LManager.delegate = self; &#125; return _LManager;&#125;- (CLGeocoder *)geocoder&#123; if (!_geocoder) &#123; _geocoder = [[CLGeocoder alloc] init]; &#125; return _geocoder;&#125; 在这里需要知道,定位在进入iOS8之后,需要修改plist文件,添加两个字段,分别是 NSLocationAlwaysUsageDescription 以及 NSLocationWhenInUseDescription 如下图所示 由于只有定位需求,所以在viewDidLoad方法里面直接写定位方法. 首先判断用户是否关闭了定位123456//判断用户是否关闭了定位 if (![CLLocationManager locationServicesEnabled]) &#123; NSLog(@&quot;定位失败&quot;); return; &#125; 版本适配12345//做版本适配(ios8以后才有的方法，所以要做适配) if ([self.LManager respondsToSelector:@selector(requestWhenInUseAuthorization)]) &#123; [self.LManager requestWhenInUseAuthorization]; &#125; 使用位置管理者,开始更新用户位置12345//使用位置管理者,开始更新用户位置 [self.LManager startUpdatingLocation]; //iOS9.0以后新的请求定位方法,不能与startUpdatingLocation同时使用 // [self.LManager requestLocation]; 让当前类遵从CLLocationManagerDelegate协议,并实现协议里面的一些方法 CLLocationManagerDelegate 定位失败时调用12345/** 定位失败时调用*/- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error&#123; NSLog(@&quot;定位失败&quot;);&#125; 位置更新后调用123456789101112131415161718/** 位置更新后调用*/- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations&#123; CLLocation *location = [locations lastObject]; [self.geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) &#123; for (CLPlacemark *placemark in placemarks) &#123; for (NSString *key in placemark.addressDictionary) &#123; NSLog(@&quot;%@ = %@&quot;,key,placemark.addressDictionary[key]); [self.label performSelectorOnMainThread:@selector(setText:) withObject:placemark.addressDictionary[@&quot;City&quot;] waitUntilDone:YES]; &#125; &#125; &#125;]; &#125; 定位服务状态改变时调用123456789101112131415161718192021222324252627282930313233343536/** 定位服务状态改变时调用*/- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status&#123; switch (status) &#123; case kCLAuthorizationStatusNotDetermined: &#123; NSLog(@&quot;用户还未决定授权&quot;); if ([manager respondsToSelector:@selector(requestWhenInUseAuthorization)]) &#123; [manager requestAlwaysAuthorization]; &#125; break; &#125; case kCLAuthorizationStatusRestricted: &#123; NSLog(@&quot;访问受限&quot;); break; &#125; case kCLAuthorizationStatusDenied: &#123; if ([CLLocationManager locationServicesEnabled]) &#123; NSLog(@&quot;定位服务开启,被拒绝&quot;); &#125; else&#123; NSLog(@&quot;定位服务关闭,不可用&quot;); &#125; break; &#125; case kCLAuthorizationStatusAuthorizedAlways: &#123; NSLog(@&quot;获得前后台授权&quot;); break; &#125; case kCLAuthorizationStatusAuthorizedWhenInUse: &#123; NSLog(@&quot;获得前后台授权&quot;); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-CollectionView瀑布流框架搭建]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-CollectionView%E7%80%91%E5%B8%83%E6%B5%81%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2FiOS-CollectionView%E7%80%91%E5%B8%83%E6%B5%81%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[CollectionView瀑布流框架搭建 CollectionView实现以下效果. 思路:先说一下这个效果的实现思路,首先需要确定该瀑布流有多少列,然后需要确定每个cell 的高度,用一个数组记录下每一列的已添加上去的cell的高度和.然后添加下一个cell的时候找出所有列中高度最小的列,再添加上去.例如:在该例子中,总共有两列,当添加完第一第二个cell,即第一行添加完了,要添加第三个cell,就需要找出第一第二列中高度最短的那一列,然后添加到最短那一列下面,以此类推. 实现:首先我们需要初始化collectionView,步骤与 “iOS-CollectionView 基础” 类似. 该效果需要自定义布局,实现瀑布流效果.创建一个布局类,继承于UICollectionViewLayout. (流水布局对应的类继承于UICollectionViewFlowLayout, UICollectionViewFlowLayout 是 UICollectionViewLayout的子类) 在布局类需要重写四个方法,分别是: ###1. 重写prepareLayout方法-作用:在这个方法做一些初始化操作-注意:一定要调用 [super prepareLayout] ###2.重写layoutAttributesForItemAtIndexPath:方法-作用:返回indexPath 位置cell对应的布局属性 ###3. 重写layoutAttributesForElementsInRect:方法-作用: 这个方法的返回值是个数组 这个数组中存放的是UICollectionViewLayoutAttributes对象 UICollectionViewLayoutAttributes 对象决定了cell的排布方式 ###4.重写collectionViewContentSize方法-作用:决定collectionView的可滚动范围 代码实现:布局类.m 文件 1.定义如下静态变量12345678/** 列数*/static const CGFloat columCount = 3;/** 每一列间距*/static const CGFloat columMargin = 10;/** 每一列间距*/static const CGFloat rowMargin = 10;/** 边缘间距*/static const UIEdgeInsets defaultEdgeInsets = &#123;10,10,10,10&#125;; 2.声明两个属性12345/** 布局属性数组*/@property (nonatomic,strong) NSMutableArray *attrsArray;/** 存放所有列的当前高度*/@property (nonatomic,strong) NSMutableArray *columnHeight; 懒加载 attrsArray, columnHeight1234567891011121314151617- (NSMutableArray *)attrsArray&#123; if (!_attrsArray) &#123; _attrsArray = [NSMutableArray array]; &#125; return _attrsArray;&#125;- (NSMutableArray *)columnHeight&#123; if (!_columnHeight) &#123; _columnHeight = [NSMutableArray array]; &#125; return _columnHeight;&#125; 重写prepareLayout方法1234567891011121314151617181920212223/** 初始化*/- (void)prepareLayout&#123; [super prepareLayout]; //如果刷新布局就会重新调用prepareLayout这个方法,所以要先把高度数组清空 [self.columnHeight removeAllObjects]; for (int i = 0; i &lt; self.columCount; i++) &#123; [self.columnHeight addObject:@(self.defaultEdgeInsets.top)]; &#125; NSInteger count = [self.collectionView numberOfItemsInSection:0]; [self.attrsArray removeAllObjects]; for (NSInteger i = 0; i &lt; count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0]; //获取indexPath 对应cell 的布局属性 UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:indexPath]; [self.attrsArray addObject:attr]; &#125;&#125; 该方法返回对应cell上的布局属性.我们可以在这个方法中设置cell 的布局样式.在prepareLayout方法中,我们根据这个方法,传入对应的IndexPath从而获取到布局属性attr,然后添加到数组中. 12345678910111213141516171819202122232425262728293031323334353637383940/** * 返回indexPath 位置cell对应的布局属性 */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes *attr = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //使用for循环,找出高度最短的那一列 //最短高度的列 NSInteger destColumn = 0; CGFloat minColumnHeight = [self.columnHeight[0] doubleValue]; for (NSInteger i = 1; i &lt; self.columCount; i++) &#123; CGFloat columnHeight =[self.columnHeight[i] doubleValue]; if (minColumnHeight &gt; columnHeight) &#123; minColumnHeight = columnHeight; destColumn = i; &#125; &#125; CGFloat w = (self.collectionView.frame.size.width - self.defaultEdgeInsets.left - self.defaultEdgeInsets.right - (self.columCount - 1) * self.columMargin )/self.columCount; //(使用代理在外部决定cell 的高度,下面会介绍) CGFloat h = [self.delegate waterFlowLayout:self heightForRowAtIndex:indexPath.item itemWidth:w]; CGFloat x = self.defaultEdgeInsets.left + destColumn*(w + self.columMargin); CGFloat y = minColumnHeight ; if (y != self.defaultEdgeInsets.top) &#123; y += self.rowMargin; &#125; attr.frame = CGRectMake(x,y,w,h); self.columnHeight[destColumn] = @(y+ h); return attr;&#125; 重写layoutAttributesForElementsInRect:方法1234567/** * 决定cell 的排布 */- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return self.attrsArray;&#125; 决定collectionView的可滚动范围1234567891011121314- (CGSize)collectionViewContentSize&#123; CGFloat maxHeight = [self.columnHeight[0] doubleValue]; for (int i = 1; i &lt; self.columCount; i++) &#123; CGFloat value = [self.columnHeight[i] doubleValue]; if (maxHeight &lt; value) &#123; maxHeight = value; &#125; &#125; return CGSizeMake(0, maxHeight+self.defaultEdgeInsets.bottom);&#125; 到此,瀑布流的效果就出来了.但是可以想到,这样来搭建布局,瀑布流的列数,cell与cell之间的间距以及边缘距就固定了,显然这是不够灵活的.我们应该要把这些参数抛给使用该布局的类去决定,这样才是一个通用的代码. 来到布局类.h 文件中,添加协议以及代理123456789101112131415161718192021222324252627282930313233@class WaterFlowLayout;@protocol WaterFlowLayoutDelegate &lt;NSObject&gt;@required//决定cell的高度,必须实现方法- (CGFloat)waterFlowLayout:(WaterFlowLayout *)waterFlowLayout heightForRowAtIndex:(NSInteger)index itemWidth:(CGFloat)width;@optional//决定cell的列数- (NSInteger)cloumnCountInWaterFlowLayout:(WaterFlowLayout *)waterFlowLayout;//决定cell 的列的距离- (CGFloat)columMarginInWaterFlowLayout:(WaterFlowLayout *)waterFlowLayout;//决定cell 的行的距离- (CGFloat)rowMarginInWaterFlowLayout:(WaterFlowLayout *)waterFlowLayout;//决定cell 的边缘距- (UIEdgeInsets)edgeInsetInWaterFlowLayout:(WaterFlowLayout *)waterFlowLayout;@end@interface WaterFlowLayout : UICollectionViewLayout/**代理*/@property (nonatomic,assign) id &lt;WaterFlowLayoutDelegate&gt;delegate;- (NSInteger)columCount;- (CGFloat)columMargin;- (CGFloat)rowMargin;- (UIEdgeInsets)defaultEdgeInsets;@end 回到布局类.m文件中,实现声明的方法.在这里需要明确,外部必须通过实现代理给定cell的高度.另外,如果外部通过实现代理给定列数、列间距、行间距、边缘距就用给定的，否则使用默认的列数、列间距、行间距、边缘距.123456789101112131415161718192021222324252627282930313233343536373839- (NSInteger)columCount&#123; if ([self.delegate respondsToSelector:@selector(cloumnCountInWaterFlowLayout:)]) &#123; return [self.delegate cloumnCountInWaterFlowLayout:self]; &#125; else&#123; return columCount; &#125;&#125;- (CGFloat)columMargin&#123; if ([self.delegate respondsToSelector:@selector(columMarginInWaterFlowLayout:)]) &#123; return [self.delegate columMarginInWaterFlowLayout:self]; &#125; else&#123; return columMargin; &#125;&#125;- (CGFloat)rowMargin&#123; if ([self.delegate respondsToSelector:@selector(rowMarginInWaterFlowLayout:)]) &#123; return [self.delegate rowMarginInWaterFlowLayout:self]; &#125; else&#123; return rowMargin; &#125;&#125;- (UIEdgeInsets)defaultEdgeInsets&#123; if ([self.delegate respondsToSelector:@selector(edgeInsetInWaterFlowLayout:)]) &#123; return [self.delegate edgeInsetInWaterFlowLayout:self]; &#125; else&#123; return defaultEdgeInsets; &#125;&#125; 到此,CollectionView瀑布流框架搭建完成了!!]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-CollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-CollectionView流水布局]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-CollectionView%E6%B5%81%E6%B0%B4%E5%B8%83%E5%B1%80%2FiOS-CollectionView%E6%B5%81%E6%B0%B4%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[CollectionView 的流水布局 使用CollectionView 的流水布局来实现以下效果 首先我们需要初始化collectionView,步骤与 “iOS-CollectionView 基础” 类似. 这一个样式选择的布局方式同样是 流水布局 ,创建一个类,让它继承于UICollectionViewFlowLayout.需要要完成的效果: 1.cell的放大和缩小 2.停止滚动时:cell居中 在这里面1.需要了解 UICollectionViewLayoutAttributes 这个类的对象: 1)一个cell 对应一个UICollectionViewLayoutAttributes 对象 2)UICollectionViewLayoutAttributes 对象决定了cell的frame 也就是说,一个LayoutAttribute就对应一个cell,修改LayoutAttribute就代表修改cell 的排布 2.需要重写四个方法,分别是1)重写prepareLayout方法2)重写layoutAttributesForElementsInRect:方法3)重写shouldInvalidateLayoutForBoundsChange:方法4)重写targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法 1.重写prepareLayout方法12345678910111213/*** 用来做布局的初始化* 注意: 一定要调用 [super prepareLayout] */- (void)prepareLayout&#123; [super prepareLayout]; //设置内边距 CGFloat inset = (self.collectionView.frame.size.width - self.itemSize.width)*0.5; self.sectionInset = UIEdgeInsetsMake(0, inset, 0, inset); //设置滚动方向 self.scrollDirection = UICollectionViewScrollDirectionHorizontal;&#125; 2.重写layoutAttributesForElementsInRect:方法1234567891011121314151617181920212223242526/** *这个方法返回值是一个数组(数组内存放着rect范围内所有元素的布局属性,即*UICollectionViewLayoutAttributes对象)* 这个方法的返回值,决定了所有rect范围内所有元素的排布 */- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; //获得super已经计算好的属性 NSArray *orignal = [super layoutAttributesForElementsInRect:rect]; NSArray *array = [[NSArray alloc] initWithArray:orignal copyItems:YES]; //计算collectionView中心点位置 CGFloat centerX = self.collectionView.contentOffset.x + self.collectionView.frame.size.width/2; for (UICollectionViewLayoutAttributes *attri in array) &#123; //cell中心点 和 collectionView最中心点x 的间距 CGFloat space = ABS(attri.center.x - centerX) ; //根据距离算缩放比例 CGFloat scale = 1- space/(self.collectionView.frame.size.width/2); //进行缩放 attri.transform = CGAffineTransformMakeScale(scale, scale); &#125; return array;&#125; 3.重写shouldInvalidateLayoutForBoundsChange:方法12345678910/** * 当collectionView的显示范围发生改变的时候,是否需要刷新重新布局 *一但重新刷新布局,就会调用 *1.prepareLayout *2.layoutAttributesForElementsInRect:(CGRect)rect 方法 */- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125; 4.重写targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法12345678910111213141516171819202122232425262728293031323334/** * 这个方法的返回值,决定了contentView停止滚动时的偏移量 * 参数: * proposedContentOffset 原本情况下,collctionView停止滚动时最终的偏移量 * velocity:滚动速率,通过这个参数可以了解滚动的方向 */- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity&#123; //计算出最终显示的矩形框 CGRect rect ; rect.origin.x = proposedContentOffset.x; rect.origin.y = 0; rect.size = self.collectionView.frame.size; //获得super已经计算好的属性 NSArray *array = [super layoutAttributesForElementsInRect:rect]; //计算CollectionView 最中心点x 的值 CGFloat centerX = proposedContentOffset.x + self.collectionView.frame.size.width/2; //存放最小的间距 CGFloat minSpace = MAXFLOAT; for (UICollectionViewLayoutAttributes *attr in array) &#123; if (ABS(minSpace) &gt; ABS(attr.center.x - centerX)) &#123; minSpace = attr.center.x - centerX; &#125; &#125; //修改原有的偏移量 proposedContentOffset.x += minSpace; return proposedContentOffset;&#125; 该布局到此写好了. 接着,自定义一个cell,继承于UICollectionViewCell,带xib,如下图 最后,再回到viewController里修改相应代码就OK了!!]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-CollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-CollectionView 基础]]></title>
    <url>%2F2018%2F03%2F31%2FiOS%2FiOS-CollectionView%20%E5%9F%BA%E7%A1%80%2FiOS-CollectionView%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CollectionView基础使用方法 我们将完成以下效果 主要步骤如下: 在延展中把 collectionView 作为属性 12345@interface ViewController ()&lt;UICollectionViewDelegate,UICollectionViewDataSource&gt;@property (nonatomic,strong) UICollectionView *collectionView;@end 123456789101112131415161718192021222324//创建 layout(此处创建的是流水布局)UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];//行距flowLayout.minimumLineSpacing = 10;//列距flowLayout.minimumInteritemSpacing = 10;//设置每个 item 的大小flowLayout.itemSize = CGSizeMake(([UIScreen mainScreen].bounds.size.width -40)/3, ([UIScreen mainScreen].bounds.size.height-80)/4);//设置 item 的上左下右的边距大小flowLayout.sectionInset = UIEdgeInsetsMake(10, 10, 20, 10);//设置 UICollectionView 的滑动方向flowLayout.scrollDirection = UICollectionViewScrollDirectionVertical; 注册 item12345678 //注册 item[self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:CellIdentifier]; //注册头部区域 [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:Header]; //注册尾部区域 [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:Footer]; 实现UICollectionViewDataSource 协议中必须实现的方法123456789101112- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 20;&#125;// The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:CellIdentifier forIndexPath:indexPath]; cell.contentView.backgroundColor = [UIColor redColor]; return cell;&#125; 实现UICollectionViewDelegate 协议中的一些方法1234567891011121314151617181920212223//该方法用于设置 collectionView 的 header 和 footer- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath&#123; //设置头部或尾部 view if (kind == UICollectionElementKindSectionHeader) &#123; UICollectionReusableView *headerView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:Header forIndexPath:indexPath]; headerView.backgroundColor = [UIColor orangeColor]; return headerView; &#125; else&#123; UICollectionReusableView *footerView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:Footer forIndexPath:indexPath]; footerView.backgroundColor = [UIColor yellowColor]; return footerView; &#125;&#125;//点击 cell 时调用响应的方法- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@&quot;didselected = %lu&quot;,indexPath.row);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-CollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建]]></title>
    <url>%2F2018%2F03%2F31%2FTools%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>个人博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BlockChain_Test]]></title>
    <url>%2F2018%2F03%2F30%2FBlockChain%2FBlockChain-Test%2F</url>
    <content type="text"><![CDATA[Welcome to BlockChain Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>BlockChain</category>
      </categories>
      <tags>
        <tag>比特币</tag>
      </tags>
  </entry>
</search>
